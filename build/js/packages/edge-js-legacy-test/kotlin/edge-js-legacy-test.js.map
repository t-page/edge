{"version":3,"file":"edge-js-legacy-test.js","sources":["Assertions.kt","../../../../../src/commonTest/kotlin/effects/OptionTest.kt"],"sourcesContent":["/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * A number of helper methods for writing unit tests.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"AssertionsKt\")\n@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n\npackage kotlin.test\n\nimport kotlin.contracts.*\nimport kotlin.internal.*\nimport kotlin.jvm.JvmName\nimport kotlin.native.concurrent.ThreadLocal\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KType\nimport kotlin.reflect.typeOf\n\n/**\n * Current adapter providing assertion implementations\n */\nval asserter: Asserter\n    get() = _asserter ?: lookupAsserter()\n\n/** Used to override current asserter internally */\n@ThreadLocal\ninternal var _asserter: Asserter? = null\n\n/** Asserts that the given [block] returns `true`. */\n@JvmName(\"assertTrueInline\")\n@InlineOnly\ninline fun assertTrue(message: String? = null, block: () -> Boolean) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertTrue(block(), message)\n}\n\n/** Asserts that the expression is `true` with an optional [message]. */\nfun assertTrue(actual: Boolean, message: String? = null) {\n    contract { returns() implies actual }\n    return asserter.assertTrue(message ?: \"Expected value to be true.\", actual)\n}\n\n/** Asserts that the given [block] returns `false`. */\n@JvmName(\"assertFalseInline\")\n@InlineOnly\ninline fun assertFalse(message: String? = null, block: () -> Boolean) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertFalse(block(), message)\n}\n\n/** Asserts that the expression is `false` with an optional [message]. */\nfun assertFalse(actual: Boolean, message: String? = null) {\n    contract { returns() implies (!actual) }\n    return asserter.assertTrue(message ?: \"Expected value to be false.\", !actual)\n}\n\n/** Asserts that the [expected] value is equal to the [actual] value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertEquals(expected: T, actual: T, message: String? = null) {\n    asserter.assertEquals(message, expected, actual)\n}\n\n/** Asserts that the difference between the [actual] and the [expected] is within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertEquals(expected: Double, actual: Double, absoluteTolerance: Double, message: String? = null) {\n    checkDoublesAreEqual(expected, actual, absoluteTolerance, message)\n}\n\n/** Asserts that the difference between the [actual] and the [expected] is within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertEquals(expected: Float, actual: Float, absoluteTolerance: Float, message: String? = null) {\n    checkFloatsAreEqual(expected, actual, absoluteTolerance, message)\n}\n\n/** Asserts that the [actual] value is not equal to the illegal value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotEquals(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotEquals(message, illegal, actual)\n}\n\n/** Asserts that the difference between the [actual] and the [illegal] is not within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertNotEquals(illegal: Double, actual: Double, absoluteTolerance: Double, message: String? = null) {\n    checkDoublesAreEqual(illegal, actual, absoluteTolerance, message, shouldFail = true)\n}\n\n/** Asserts that the difference between the [actual] and the [illegal] is not within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertNotEquals(illegal: Float, actual: Float, absoluteTolerance: Float, message: String? = null) {\n    checkFloatsAreEqual(illegal, actual, absoluteTolerance, message, shouldFail = true)\n}\n\n/** Asserts that [expected] is the same instance as [actual], with an optional [message]. */\nfun <@OnlyInputTypes T> assertSame(expected: T, actual: T, message: String? = null) {\n    asserter.assertSame(message, expected, actual)\n}\n\n/** Asserts that [actual] is not the same instance as [illegal], with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotSame(message, illegal, actual)\n}\n\n/**\n * Asserts that [value] is of type [T], with an optional [message].\n *\n * Note that due to type erasure the type check may be partial (e.g. `assertIs<List<String>>(value)`\n * only checks for the class being [List] and not the type of its elements because it's erased).\n */\n@SinceKotlin(\"1.5\")\n@InlineOnly\n@OptIn(ExperimentalStdlibApi::class)\ninline fun <reified T> assertIs(value: Any?, message: String? = null): T {\n    contract { returns() implies (value is T) }\n    assertIsOfType(value, typeOf<T>(), value is T, message)\n    return value as T\n}\n\n@PublishedApi\ninternal fun assertIsOfType(value: Any?, type: KType, result: Boolean, message: String?) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected value to be of type <$type>, actual <${value?.let { it::class }}>.\" }, result)\n}\n\n/**\n * Asserts that [value] is not of type [T], with an optional [message].\n *\n * Note that due to type erasure the type check may be partial (e.g. `assertIsNot<List<String>>(value)`\n * only checks for the class being [List] and not the type of its elements because it's erased).\n */\n@SinceKotlin(\"1.5\")\n@InlineOnly\n@OptIn(ExperimentalStdlibApi::class)\ninline fun <reified T> assertIsNot(value: Any?, message: String? = null) {\n    assertIsNotOfType(value, typeOf<T>(), value !is T, message)\n}\n\n@PublishedApi\ninternal fun assertIsNotOfType(@Suppress(\"UNUSED_PARAMETER\") value: Any?, type: KType, result: Boolean, message: String?) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected value to not be of type <$type>.\" }, result)\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message]. */\nfun <T : Any> assertNotNull(actual: T?, message: String? = null): T {\n    contract { returns() implies (actual != null) }\n    asserter.assertNotNull(message, actual)\n    return actual!!\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message] and a function [block] to process the not-null value. */\n@JvmName(\"assertNotNullInline\")\n@InlineOnly\ninline fun <T : Any, R> assertNotNull(actual: T?, message: String? = null, block: (T) -> R) {\n    contract { returns() implies (actual != null) }\n    block(assertNotNull(actual, message))\n}\n\n/** Asserts that the [actual] value is `null`, with an optional [message]. */\nfun assertNull(actual: Any?, message: String? = null) {\n    asserter.assertNull(message, actual)\n}\n\n/** Asserts that the [iterable] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(iterable: Iterable<T>, element: T, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the collection to contain the element.\\nCollection <$iterable>, element <$element>.\" },\n        iterable.contains(element)\n    )\n}\n\n/** Asserts that the [sequence] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(sequence: Sequence<T>, element: T, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the sequence to contain the element.\\nSequence <$sequence>, element <$element>.\" },\n        sequence.contains(element)\n    )\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(array: Array<T>, element: T, message: String? = null) {\n    assertArrayContains(array, element, message, Array<T>::contains, Array<T>::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: ByteArray, element: Byte, message: String? = null) {\n    assertArrayContains(array, element, message, ByteArray::contains, ByteArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: ShortArray, element: Short, message: String? = null) {\n    assertArrayContains(array, element, message, ShortArray::contains, ShortArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: IntArray, element: Int, message: String? = null) {\n    assertArrayContains(array, element, message, IntArray::contains, IntArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: LongArray, element: Long, message: String? = null) {\n    assertArrayContains(array, element, message, LongArray::contains, LongArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: BooleanArray, element: Boolean, message: String? = null) {\n    assertArrayContains(array, element, message, BooleanArray::contains, BooleanArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: CharArray, element: Char, message: String? = null) {\n    assertArrayContains(array, element, message, CharArray::contains, CharArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UByteArray, element: UByte, message: String? = null) {\n    assertArrayContains(array, element, message, UByteArray::contains, UByteArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UShortArray, element: UShort, message: String? = null) {\n    assertArrayContains(array, element, message, UShortArray::contains, UShortArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UIntArray, element: UInt, message: String? = null) {\n    assertArrayContains(array, element, message, UIntArray::contains, UIntArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: ULongArray, element: ULong, message: String? = null) {\n    assertArrayContains(array, element, message, ULongArray::contains, ULongArray::contentToString)\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun <@OnlyInputTypes A, E> assertArrayContains(\n    array: A,\n    element: E,\n    message: String? = null,\n    contains: A.(E) -> Boolean,\n    crossinline contentToString: A.() -> String\n) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the array to contain the element.\\nArray <${array.contentToString()}>, element <${element.toString()}>.\" }, // Explicitly call toString(): KT-45684\n        array.contains(element)\n    )\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: IntRange, value: Int, message: String? = null) {\n    assertRangeContains(range, value, message, IntRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: LongRange, value: Long, message: String? = null) {\n    assertRangeContains(range, value, message, LongRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <T : Comparable<T>> assertContains(range: ClosedRange<T>, value: T, message: String? = null) {\n    assertRangeContains(range, value, message, ClosedRange<T>::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: CharRange, value: Char, message: String? = null) {\n    assertRangeContains(range, value, message, CharRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(range: UIntRange, value: UInt, message: String? = null) {\n    assertRangeContains(range, value, message, UIntRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(range: ULongRange, value: ULong, message: String? = null) {\n    assertRangeContains(range, value, message, ULongRange::contains)\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun <R, V> assertRangeContains(range: R, value: V, message: String? = null, contains: R.(V) -> Boolean) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the range <$range> to contain the value <${value.toString()}>.\" }, // Explicitly call toString(): KT-45684\n        range.contains(value)\n    )\n}\n\n/** Asserts that the [map] contains the specified [key], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes K, V> assertContains(map: Map<K, V>, key: K, message: String? = null) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected the map to contain the key.\\nMap <$map>, key <$key>.\" }, map.containsKey(key))\n}\n\n/**\n * Asserts that the [charSequence] contains the specified [char], with an optional [message].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, char: Char, ignoreCase: Boolean = false, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the char.\\nCharSequence <$charSequence>, char <$char>, ignoreCase <$ignoreCase>.\" },\n        charSequence.contains(char, ignoreCase)\n    )\n}\n\n/**\n * Asserts that the [charSequence] contains the specified [other] char sequence as a substring, with an optional [message].\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, other: CharSequence, ignoreCase: Boolean = false, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the substring.\\nCharSequence <$charSequence>, substring <$other>, ignoreCase <$ignoreCase>.\" },\n        charSequence.contains(other, ignoreCase)\n    )\n}\n\n/** Asserts that the [charSequence] contains at least one match of the specified regular expression [regex], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, regex: Regex, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the regular expression.\\nCharSequence <$charSequence>, regex <$regex>.\" },\n        charSequence.contains(regex)\n    )\n}\n\n/**\n * Asserts that the [expected] iterable is *structurally* equal to the [actual] iterable,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Iterable<T>?, actual: Iterable<T>?, message: String? = null) {\n    assertIterableContentEquals(\"Iterable\", message, expected, actual, Iterable<*>::iterator)\n}\n\n\n@SinceKotlin(\"1.5\")\n@Deprecated(\"'assertContentEquals' for Set arguments is ambiguous. Use 'assertEquals' to compare content with the unordered set equality, or cast one of arguments to Iterable to compare the set elements in order of iteration.\",\n            level = DeprecationLevel.ERROR,\n            replaceWith = ReplaceWith(\"assertContentEquals(expected, actual?.asIterable(), message)\"))\nfun <@OnlyInputTypes T> assertContentEquals(expected: Set<T>?, actual: Set<T>?, message: String? = null): Unit =\n    assertContentEquals(expected, actual?.asIterable(), message)\n\n/**\n * Asserts that the [expected] sequence is *structurally* equal to the [actual] sequence,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Sequence<T>?, actual: Sequence<T>?, message: String? = null) {\n    assertIterableContentEquals(\"Sequence\", message, expected, actual, Sequence<*>::iterator)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Array<T>?, actual: Array<T>?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, Array<*>::get, Array<*>?::contentToString, Array<*>?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: ByteArray?, actual: ByteArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ByteArray::get, ByteArray?::contentToString, ByteArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: ShortArray?, actual: ShortArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ShortArray::get, ShortArray?::contentToString, ShortArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: IntArray?, actual: IntArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, IntArray::get, IntArray?::contentToString, IntArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: LongArray?, actual: LongArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, LongArray::get, LongArray?::contentToString, LongArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: FloatArray?, actual: FloatArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, FloatArray::get, FloatArray?::contentToString, FloatArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: DoubleArray?, actual: DoubleArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, DoubleArray::get, DoubleArray?::contentToString, DoubleArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: BooleanArray?, actual: BooleanArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, BooleanArray::get, BooleanArray?::contentToString, BooleanArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: CharArray?, actual: CharArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, CharArray::get, CharArray?::contentToString, CharArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UByteArray?, actual: UByteArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UByteArray::get, UByteArray?::contentToString, UByteArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UShortArray?, actual: UShortArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UShortArray::get, UShortArray?::contentToString, UShortArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UIntArray?, actual: UIntArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UIntArray::get, UIntArray?::contentToString, UIntArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: ULongArray?, actual: ULongArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ULongArray::get, ULongArray?::contentToString, ULongArray?::contentEquals)\n}\n\n/** Marks a test as having failed if this point in the execution path is reached, with an optional [message]. */\nfun fail(message: String? = null): Nothing {\n    asserter.fail(message)\n}\n\n/**\n * Marks a test as having failed if this point in the execution path is reached, with an optional [message]\n * and [cause] exception.\n *\n * The [cause] exception is set as the root cause of the test failure.\n */\n@SinceKotlin(\"1.4\")\nfun fail(message: String? = null, cause: Throwable? = null): Nothing {\n    asserter.fail(message, cause)\n}\n\n/** Asserts that given function [block] returns the given [expected] value. */\n@JvmName(\"expectInline\")\n@InlineOnly\ninline fun <@OnlyInputTypes T> expect(expected: T, block: () -> T) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertEquals(expected, block())\n}\n\n/** Asserts that given function [block] returns the given [expected] value and use the given [message] if it fails. */\n@JvmName(\"expectInline\")\n@InlineOnly\ninline fun <@OnlyInputTypes T> expect(expected: T, message: String?, block: () -> T) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertEquals(expected, block(), message)\n}\n\n/**\n * Asserts that given function [block] fails by throwing an exception.\n *\n * @return An exception that was expected to be thrown and was successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsInline\")\ninline fun assertFails(block: () -> Unit): Throwable =\n    checkResultIsFailure(null, runCatching(block))\n\n/**\n * Asserts that given function [block] fails by throwing an exception.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception that was expected to be thrown and was successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@SinceKotlin(\"1.1\")\n@InlineOnly\n@JvmName(\"assertFailsInline\")\ninline fun assertFails(message: String?, block: () -> Unit): Throwable =\n    checkResultIsFailure(message, runCatching(block))\n\n@PublishedApi\ninternal fun checkResultIsFailure(message: String?, blockResult: Result<Unit>): Throwable {\n    blockResult.fold(\n        onSuccess = {\n            asserter.fail(messagePrefix(message) + \"Expected an exception to be thrown, but was completed successfully.\")\n        },\n        onFailure = { e ->\n            return e\n        }\n    )\n}\n\n/** Asserts that a [block] fails with a specific exception of type [T] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\ninline fun <reified T : Throwable> assertFailsWith(message: String? = null, block: () -> Unit): T =\n    assertFailsWith(T::class, message, block)\n\n/**\n * Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsWithInline\")\ninline fun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, block: () -> Unit): T = assertFailsWith(exceptionClass, null, block)\n\n/**\n * Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsWithInline\")\ninline fun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, message: String?, block: () -> Unit): T =\n    checkResultIsFailure(exceptionClass, message, runCatching(block))\n\n/** Platform-specific construction of AssertionError with cause */\ninternal expect fun AssertionErrorWithCause(message: String?, cause: Throwable?): AssertionError\n\n/**\n * Abstracts the logic for performing assertions. Specific implementations of [Asserter] can use JUnit\n * or TestNG assertion facilities.\n */\ninterface Asserter {\n    /**\n     * Fails the current test with the specified message.\n     *\n     * @param message the message to report.\n     */\n    fun fail(message: String?): Nothing\n\n    /**\n     * Fails the current test with the specified message and cause exception.\n     *\n     * @param message the message to report.\n     * @param cause the exception to set as the root cause of the reported failure.\n     */\n    @SinceKotlin(\"1.4\")\n    fun fail(message: String?, cause: Throwable?): Nothing\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param lazyMessage the function to return a message to report if the assertion fails.\n     */\n    fun assertTrue(lazyMessage: () -> String?, actual: Boolean): Unit {\n        if (!actual) {\n            fail(lazyMessage())\n        }\n    }\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertTrue(message: String?, actual: Boolean): Unit {\n        assertTrue({ message }, actual)\n    }\n\n    /**\n     * Asserts that the specified values are equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertEquals(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual>.\" }, actual == expected)\n    }\n\n    /**\n     * Asserts that the specified values are not equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotEquals(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Illegal value: <$actual>.\" }, actual != illegal)\n    }\n\n    /**\n     * Asserts that the specified values are the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertSame(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual> is not same.\" }, actual === expected)\n    }\n\n    /**\n     * Asserts that the specified values are not the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotSame(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected not same as <$actual>.\" }, actual !== illegal)\n    }\n\n    /**\n     * Asserts that the specified value is `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be null, but was: <$actual>.\" }, actual == null)\n    }\n\n    /**\n     * Asserts that the specified value is not `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be not null.\" }, actual != null)\n    }\n\n}\n\n/**\n * Checks applicability and provides Asserter instance\n */\ninterface AsserterContributor {\n    /**\n     * Provides [Asserter] instance or `null` depends on the current context.\n     *\n     * @return asserter instance or null if it is not applicable now\n     */\n    fun contribute(): Asserter?\n}\n\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;mBAgCA,kD;EC3BA,sB;G;wCACI,Y;IAEI,mBAAmB,WAAW,aAAX,C;ID6BvB,WC5BiB,iCD4BjB,EAFqC,IAErC,C;EC3BA,C;;;;;;;;;;;;;;;;;;;"}